[Анатомия проекта Django/HTMX
](https://danjacob.net/posts/anatomyofdjangohtmxproject/)

29 января 2022 [DJANGO](https://danjacob.net/tags/django/) / [JAVASCRIPT](https://danjacob.net/tags/javascript/) / [HTMX](https://danjacob.net/tags/htmx/) / [PYTHON](https://danjacob.net/tags/python/) / [WEB DEVELOPMENT](https://danjacob.net/tags/web-development/)

# Введение

В [предыдущей статье](https://danjacob.net/posts/djangohtmxalpine) я дал очень общее описание HTMX и Alpine и их места в современном технологическом стеке веб-приложений. В ней было мало деталей, а по нескольким фрагментам кода трудно сделать какие-либо выводы. Я решил создать проект, который позволил бы более детально рассмотреть взаимодействие Django и HTMX.

Люди из Thinkster создали демонстрационное [приложение "реального мира"](https://github.com/gothinkster/realworld/), основанное на клоне Medium. Разработчики могут скопировать этот проект и реализовать его, используя любой фронтенд и бэкенд по своему усмотрению, что дает возможность сравнить различные фреймворки и поучиться работе с каждым из них. Клон Medium - это хороший выбор, поскольку блог - это хорошо понятная концепция, не требующая объяснения сложных бизнес-требований, и он также охватывает многие основы, необходимые практически для всех серьезных веб-приложений, например, аутентификацию, права доступа пользователей, проверку форм, интеграцию с REST API и т.д. Макеты и тема Bootstrap уже предоставлены, так что вам не придется тратить много времени на дизайн, а также проще проводить сравнения между реализациями, поскольку внешний вид и функциональность будут практически идентичны.

Мою реализацию можно посмотреть [здесь](https://github.com/danjac/realworld), а при желании, следуя README, можно запустить ее локально. Это не совсем точная реализация спецификации Thinkster, например, спецификация действительно хочет, чтобы у вас были отдельные реализации фронтенда и бэкенда с очень специфическим API, в то время как эта реализация, очевидно, не собрана таким образом. Тем не менее она служит точкой сравнения с традиционной "SPA"-реализацией, использующей, скажем, Django Rest Framework и React.

# Начните с проекта Django и доработайте его

За исключением некоторых дискретных AJAX-действий (о них подробнее позже), этот проект построен как традиционный (не-SPA). Я добавил `hx-boost` для обеспечения мгновенной "SPA-lite" навигации, подобной [Turbolinks/Hotwire](https://turbo.hotwired.dev/):

```html
<body hx-boost="true">
```

Готовая реализация `hx-boost` автоматически подменяет внутренний HTML тега `<body>` содержимым `<body>` ответа, игнорируя `<head>` за исключением тега `<title>`, обеспечивая более плавный переход между страницами при переходе по ссылкам и размещении форм, чем полная перезагрузка страницы.

При использовании `hx-boost` я отключаю функцию [кэширования истории HTMX](https://htmx.org/docs/#history), которая иногда приводит к странному поведению при перезагрузке страницы с помощью кнопки "Назад":

```html
<meta name="htmx-config" content='{"historyCacheSize": 0, "refreshOnHistoryMiss": false}'>
```

# Не забудьте передать токен CSRF

Если вы попытаетесь использовать в Django действие, отличное от GET, то по умолчанию получите неприятный ответ `HTTP 403`, если забудете передать токен CSRF. Это легко сделать в формах: просто используйте тег `{% csrf_token %}`, который отображает токен внутри скрытого `<input>`. Если вы используете `hx-post` или другое действие, не относящееся к GET HTMX, вне формы, вы не сможете использовать этот тег. Вместо него нужно включить заголовок запроса `X-CSRFToken`, который Django проверит, нет ли скрытого значения формы ввода. Например, наше действие выхода из системы выглядит следующим образом:

```html
<a class="nav-link"
    href="javascript:void(0)"
    hx-post="{% url 'logout' %}"
    hx-target="body"
    hx-push-url="true"
    hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'>
    Sign Out
</a>
```

Передавать этот атрибут `hx-headers` каждому действию AJAX POST или DELETE может быть несколько утомительно, но, к счастью, одна из основных концепций HTMX заключается в том, что директива может быть расширена на все дочерние элементы. Например, мы можем добавить заголовок к элементу верхнего уровня:

```html
<div class="article-page" hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'>
```

Все действия HTMX внутри `<div>` теперь будут автоматически включать заголовок X-CSRFToken.

Заманчиво просто добавить эту директиву один раз в `<body>`, но это приведет к ошибке - поскольку `hx-boost` заменяет внутренний HTML, значение в атрибуте `<body>` будет рассинхронизировано, когда Django создаст новую HTML-страницу со свежим токеном. Поэтому лучше задавать этот атрибут в элементе внутри `<body>`.

# Магия OOB

Одна из проблем, возникающих при работе со спецификацией, связана с кнопками "Избранное" и "Следовать" на странице подробного описания статьи. Кнопки отображаются дважды - вверху и внизу страницы. Это вполне логично, так как вы не хотите заставлять пользователя прокручивать страницу вперед и назад, когда он хочет выполнить одно из этих действий, особенно если статья очень длинная. Однако это создает определенные трудности.

Обычно, когда мы возвращаем HTML-сниппет из действия HTMX, например, кнопки, мы хотим вернуть только саму кнопку с новым состоянием. Так, если у вас есть действие "Подписаться", вызываемое кнопкой, вы хотите вернуть соответствующую кнопку "Отписаться". С точки зрения пользователя, нажатие на кнопку изменяет иконку или текст с "Подписаться" на "Отписаться".

Однако что делать, если требуется изменить два или более элементов? Здесь возникает сложность, поскольку HTMX ожидает, что цель будет одним элементом. Даже если я передам CSS-селектор, он выберет первый выбранный элемент, а не все элементы, соответствующие классу.

Решение состоит в том, чтобы добавить в ответ элементы ["вне диапазона" (OOB)](https://htmx.org/attributes/hx-swap-oob/). Например, если мы нажмем верхнюю кнопку "Избранное", то получим в ответ что-то вроде этого:

```html
<button id="follow-top"
    hx-delete="/favorite/12345/"
    hx-swap="outerHTML"
    hx-target="this">
    Remove Favorite
    </button>

<button id="follow-bottom"
    hx-delete="/favorite/12345/"
    hx-swap="outerHTML"
    hx-target="this"
    hx-swap-oob="true">
    Remove Favorite
    </button>
```

Вторая кнопка имеет директиву `hx-swap-oob="true"`, которая предписывает HTMX вставить эту кнопку на место соответствующей ID в DOM. С точки зрения пользователя, обе кнопки обновляются мгновенно. Поскольку я использую промежуточное ПО [django-htmx](https://github.com/adamchainz/django-htmx), я могу проверить целевое назначение, например, из экземпляра `request.htmx`:

```py
oob_target = 'follow-bottom' if request.htmx.target == 'follow-top' else 'follow-top'
```

Можно добавить любое количество OOB-элементов: например, обновить итоговую сумму в виджете корзины или выдать пользователю "флэш"-сообщение об успешном действии (очевидно, если требуется обновлять множество дискретных элементов, проще сделать полное обновление страницы или переадресацию клиента).

# DRY ваши шаблоны

Лучшим шаблоном для повторного использования шаблонов Django с HTMX является разбиение функциональности на части шаблонов. Я придерживаюсь традиции префиксации частичных шаблонов знаком подчеркивания, например, `_article_form.html`, некоторые предпочитают использовать подкаталоги частичных шаблонов или вообще отказаться от шаблонов и выводить HTML частичные шаблоны с помощью функции `django.utils.html.format_html`, но основная схема остается неизменной.

Например, страница создания/обновления статьи выглядит следующим образом:

```html
<div class="col-md-10 offset-md-1 col-xs-12">
    {% include "articles/_article_form.html" %}
</div>
```

При обработке формы мы можем вернуть частицу `_article_form.html`, если форма содержит ошибки:

```py
return TemplateResponse(request, "articles/_article_form.html", {"form": form})
```

# Настройка форм

Формы Django могут быть немного сложными в настройке, особенно если вы хотите добавить к полям формы пользовательские атрибуты HTMX или Alpine или классы CSS (как в примере ниже). Обычно виджет настраивается после первоначального создания формы, например:

```py
class MyForm(forms.Form):

    name = forms.CharField(required=True, max_length=60)

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields["name"].widget.attrs["class"] = "form-control"
```

С таким подходом связаны две проблемы. Во-первых, он снижает возможность повторного использования формы: например, предположим, я хочу использовать `form-control-lg` при отображении `MyForm` на одной странице, а `form-control` - на другой? Во-вторых, это нарушает разделение задач: CSS-класс должен быть действительно тем, что я могу настроить в шаблоне, а не в классе формы. Например, фронтенд-разработчик может захотеть изменить имена классов, и наличие класса в коде Python несколько усложняет эту задачу, а настройка формы внутри представления Django быстро приводит к очень громоздкому коду:

```py
def my_view(request):

    if request.method == "POST":
        form = MyForm(request.POST)
        # validate, process etc....
    else:
        form = MyForm()

    # customize for our specific view...
    form.fields["name"].widget.attrs["class"] = "form-control"
    # and do the same for all our other fields...
```

[django-crispy-forms](https://django-crispy-forms.readthedocs.io/) - это популярная библиотека для обеспечения лучшего управления и настройки форм и виджетов Django, которая хорошо работает с CSS-фреймворками, такими как Bootstrap. Однако мне лично больше всего нравится [django-widget-tweaks](https://pypi.org/project/django-widget-tweaks/), которая позволяет настраивать формы непосредственно в шаблонах с помощью некоторых пользовательских тегов:

```html
{% load widget_tweaks %}
{% render_field form.name class+="form-control" hx-get="/lookup" placeholder="Your name" %}
```

Это приведет к тому, что входные атрибуты будут выглядеть примерно так:

```html
<input type="text"
        name="name"
        id="id_name"
        class="form-control"
        hx-get="/lookup"
        placeholder="Your name">
```

# Немного Alpine

Наконец, я добавил небольшой фрагмент Alpine. Для этого проекта требовалось так мало Javascript, что добавление зависимости Alpine было, пожалуй, излишним, но я счел это полезным в качестве упражнения.

В форме статьи (т.е. при размещении новой статьи или редактировании существующей) есть поле ввода "Tags". Спецификация требует наличия функции "typeahead", чтобы при вводе тегов все совпадающие теги, уже имеющиеся в базе данных, отображались под вводом:

![Отображённые тэги](https://danjacob.net/img/tags_0.png)

При нажатии на тег он должен заменять последние несколько букв, которые вы набрали, на этот тег:

![Автодополнение в поле ввода тэгов](https://danjacob.net/img/tags_1.png)

Вся реализация состоит всего из нескольких строк:

```html
<fieldset class="form-group"
        x-data="{
            insertTag(tag) {
            let tags = $refs.input.value.split(' ').slice(0, -1);
            tags.push(tag);
            $refs.input.value = tags.join(' ');
            $refs.input.focus();
            $refs.list.innerHTML = '';
            }
        }">
    {% url 'tags_autocomplete' as tags_autocomplete_url %}
    {% render_field form.tags class+="form-control" placeholder="Enter tags" x-ref="input" hx-trigger="keyup changed delay:200ms" hx-target="#tags-list" hx-swap="innerHTML" hx-get=tags_autocomplete_url autocomplete="off" %}
    <div class="tag-list" id="tags-list" x-ref="list"></div>
</fieldset>
```

Это показывает, насколько хорошо Alpine и HTMX работают вместе. Всякий раз, когда пользователь начинает набирать какие-то буквы, HTMX получает ответ - ноль или несколько меток - в элемент `tags-list`. Каждая метка выглядит следующим образом:

```html
<a class="tag" @click="insertTag('python')">python</a>
```

Таким образом, когда пользователь щелкает на этом теге, в поле ввода вставляется текст "python", а список тегов очищается. Альпийские `$refs` и `x-ref` позволяют обращаться к конкретным элементам с областью видимости `x-data`.

Разумеется, это очень упрощенная реализация, не охватывающая множество крайних случаев, но она показывает, как можно использовать немного Javascript с Alpine для выполнения большого объема работы.
